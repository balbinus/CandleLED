/**
 * CandleFlickerLED.c forked from https://github.com/cpldcpu/CandleLEDhack.
 *
 * Emulates a candleflicker-LED on an AVR microcontroller.
 */

#include <avr/io.h>
#include <avr/interrupt.h>

/**
 * This is a 32-bit long LFSR. The point is to decrease repetition in the
 * sequences, but it takes a toll on performance (slightly) and on program/
 * memory size (see http://www.ece.cmu.edu/~koopman/lfsr/index.html on LFSRs).
 * 
 * Values are inverted so the LFSR also works with zero initialization.
 * 
 * (Ended up inlined in Assembly, because of the 0xFF = 1's complement
 * optimization).
 */
#define LFSR_FEEDBACK_TERM 0x7FFFF159

// Led connected to PB0
#define LEDDDR  DDRB
#define LEDPIN  PB0

// Select only the lowest byte (GCC ASM optim)
#define low_byte(x) ((uint8_t) x)

uint8_t  FRAME_CTR = 0;
uint32_t RAND      = 0;

int main(void)
{
    cli();

    /**
     * CPU base frequency (fuses)     = 4.8 MHz
     * CPU clock division factor      = 4
     * CPU frequency                  = 1.2 MHz
     * 
     * Counter0 clock division factor = 8
     * Counter0 steps                 = 256 (8 bits)
     * Counter0 overflows in a frame  = 32
     * 
     * Hence:
     * PWM change frequency           = 18,31 Hz
     * PWM change period              = 54,61 ms
     * 
     * To avoid unintentional changes of clock frequency, a special write
     * procedure must be followed to change the CLKPS bits:
     * 1. Write the Clock Prescaler Change Enable (CLKPCE) bit to one and all 
     * other bits in CLKPR to zero.
     * 2. Within four cycles, write the desired value to CLKPS while writing a
     * zero to CLKPCE.
     */
    CLKPR = _BV(CLKPCE);
    CLKPR = _BV(CLKPS1);                // Set clk division factor to 4
	
    // Set output pin direction
    LEDDDR |= _BV(LEDPIN);              // LED is connected to PB0
    
    // Timer/Counter Control Register A
#ifdef __INVERTED_PWM
    TCCR0A = _BV(COM0A1) | _BV(COM0A0)  // Inverted PWM (0 at start, 1 on match)
#else
    TCCR0A = _BV(COM0A1)                // "Normal" PWM (1 at start, 0 on match)
#endif
           | _BV(WGM01)  | _BV(WGM00);  // Fast PWM mode 0x00-0xFF then overflow
    // Timer/Counter Control Register B
    TCCR0B = _BV(CS01);                 // Counter started, f/8
    // Timer/Counter Interrupt Mask Register
    TIMSK0 = _BV(TOIE0);                // Timer/Counter0 Overflow Int Enable
    OCR0A = 0;
    
    sei();
    
    while (1);
}

/**
 * ISR triggered on Timer0 overflow. Overflow of the timer = frame counter
 * increment.
 * 
 * Naked function means that no prologue (registers pushed to stack) or epilogue
 * (register popped from stack) is generated by the compiler. Since this is
 * actually the only function ever called (after main is done setting up
 * interrupts), we don't really care about the registers state. We need to call
 * reti ourselves, though, since it's part of the epilogue.
 */
 __attribute__((naked)) ISR(TIM0_OVF_vect)
{
/*
    FRAME_CTR++;
    FRAME_CTR &= 0x1F;
*/
    /**
     * Generate a new random brightness value at the bottom of each frame, and
     * if the number we've generated is deemed invalid, we retry up to three
     * times to make a new one (& 0x07).
     * 
     * Bad values are those whose bits 2 and 3 (0b1100 = 0xC) are not set. These
     * values will be too low for our flicker to work.
     * 
     * (uint8_t) conversion (via low_byte()) is here to simplify asm code and
     * compare only on the byte we need.
     * 
     * We use inline Assembly because GCC will add unnecessary MOVW & loads.
     */
/*
    if (FRAME_CTR == 0 || (((FRAME_CTR & 0x7) == 0) && ((low_byte(RAND) & 0xC) == 0)))
    {
        if ((RAND & 1) == 1) RAND >>= 1;
        else RAND = (RAND >> 1) ^ LFSR_FEEDBACK_TERM;
    }
*/
    /**
     * Top of a frame: set the new PWM value from the generated randomness.
     * 
     * We saturate the 5-bit random value to 4 bits so that 50% of the time, the
     * LED is full on.
     * 
     * The bit shift is here to fill the 8 bits of the PWM counter.
     * 
     * See above for low_byte().
     */
/*
    if (FRAME_CTR == 0x1F)
    {
        OCR0A = (low_byte(RAND) & 0x10) > 0 ? 0xFF : (low_byte(RAND) << 4) | 0xF;
    }

    reti(); // needed if naked.
*/

    __asm__(
            "subi %1,lo8(-(1))" "\n\t" // FRAME_CTR++
            "andi %1,0x1F" "\n\t" // FRAME_CTR &= 0x1F

            "mov r31,%1" "\n\t"
            "tst %1" "\n\t"         // if (FRAME_CTR == 0) goto NEW_RAND
            "breq .LNEW_RAND" "\n\t"
            "andi r31,lo8(7)" "\n\t" // if ((FRAME_CTR & 0x7) != 0) goto NEW_PWM
            "brne .LNEW_PWM" "\n\t"
            "mov r31,%A0" "\n\t"
            "andi r31,lo8(12)" "\n\t" // if ((RAND & 0xC) != 0) goto NEW_PWM
            "brne .LNEW_PWM" "\n"

        ".LNEW_RAND:" "\n\t"
            "mov r31,%A0" "\n\t"
            "lsr %D0" "\n\t"    // RAND >>= 1
            "ror %C0" "\n\t"
            "ror %B0" "\n\t"
            "ror %A0" "\n\t"

            "sbrc r31,0" "\n\t"  // if !(old_RAND & 1) goto NEW_PWM
            "rjmp .LNEW_PWM" "\n\t"

            "ldi r31,0x59" "\n\t"   // RAND ^= LFSR_FEEDBACK_TERM
            "eor %A0,r31" "\n\t"
            "ldi r31,0xF1" "\n\t"
            "eor %B0,r31" "\n\t"
            //~ "ldi r31,0xFF" "\n\t"
            //~ "eor %C0,r31" "\n\t"
            "com %C0" "\n\t"
            "ldi r31,0x7F" "\n\t"
            "eor %D0,r31" "\n"

        ".LNEW_PWM:" "\n\t"
            "cpi %1,0x1F" "\n\t" // if (FRAME_CTR != 0x1F) reti;
            "brne .LRETI" "\n\t"

            "ldi r31,0xFF" "\n\t"
            "sbrc %A0,4" "\n\t" // if (RAND & 0x10) PWM = 0xFF;
            "rjmp .LSET_PWM" "\n\t"

            "mov r31,%A0" "\n\t" // else PWM = (low_byte(RAND) << 4) | 0xF
            "swap r31" "\n\t"
            "ori r31,0x0F" "\n" // 0x0F

        ".LSET_PWM:" "\n\t"
            "out %4,r31" "\n"

        ".LRETI:"

            : "=r" (RAND), "=r" (FRAME_CTR)
            : "0" (RAND), "1" (FRAME_CTR), "I" (_SFR_IO_ADDR(OCR0A))
            : "r31"
           );
    reti(); // has to be out of the block because of variables
}
